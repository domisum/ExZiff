package de.domisum.exziff.generator.continentshape;

import de.domisum.lib.auxilium.data.container.math.LineSegment2D;
import de.domisum.lib.auxilium.data.container.math.Vector2D;
import de.domisum.lib.auxilium.data.container.math.shape.Polygon2D;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Checks if polygons generated by the ContinentsBasePolygonGenerator or altered by the ContinentsPolygonDeformer conform to certain rules.
 */
public class ContinentsPolygonValidator
{

	// CONSTANTS
	private static final Polygon2D OUTSIDE_EDGE_POLYGON = new Polygon2D(
			new Vector2D(0, 0),
			new Vector2D(1, 0),
			new Vector2D(1, 1),
			new Vector2D(0, 1),
			new Vector2D(0, 0),
			new Vector2D(-1, 2),
			new Vector2D(2, 2),
			new Vector2D(2, -1)
	);

	// SETTINGS
	@Getter
	@Setter
	private double minToOtherPolygonDistance = 0.08;
	@Getter
	@Setter
	private double minToEdgeDistance = 0.08;
	@Getter
	@Setter
	private double minConvexCornerAngleDeg = 35;
	@Getter
	@Setter
	private double minConcaveCornerAngleDeg = 50;
	@Getter
	@Setter
	private double minLineToLineDistance = 0.06;

	@Getter
	@Setter
	private double lineDistanceBufferDistance = 0.05;


	// VALIDATION
	public boolean isPolygonValid(Polygon2D toValidate, Polygon2D toReplace, List<Polygon2D> allPolygons)
	{
		Set<Polygon2D> otherPolygons = new HashSet<>(allPolygons);
		otherPolygons.remove(toReplace);

		return new IsPolygonValidMethodObject(toValidate, otherPolygons).isPolygonValid();
	}

	@AllArgsConstructor
	private class IsPolygonValidMethodObject
	{

		private Polygon2D toValidate;
		private Set<Polygon2D> otherPolygons;


		public boolean isPolygonValid()
		{
			if(doesPolygonSelfIntersect())
				return false;

			if(isPolygonTooCloseToOtherPolygons())
				return false;

			if(isPolygonTooCloseToEdge())
				return false;

			if(doesPolygonHaveTooPointyAngles())
				return false;

			// avoid very narrow landbridges and very narrow sections of sea
			if(isPolygonTooCloseToSelf())
				return false;

			return true;
		}


		private boolean doesPolygonSelfIntersect()
		{
			for(LineSegment2D lineSegment : toValidate.getLines())
			{
				int intersects = 0;
				for(LineSegment2D ls : toValidate.getLines())
					if(!lineSegment.equals(ls) && lineSegment.intersects(ls))
						intersects++;

				if(intersects != 2)
					return true;
			}

			return false;
		}

		private boolean isPolygonTooCloseToOtherPolygons()
		{
			for(Polygon2D p : otherPolygons)
				if(toValidate.getDistanceTo(p) < minToOtherPolygonDistance)
					return true;

			return false;
		}

		private boolean isPolygonTooCloseToEdge()
		{
			return OUTSIDE_EDGE_POLYGON.getDistanceTo(toValidate) < minToEdgeDistance;
		}

		private boolean doesPolygonHaveTooPointyAngles()
		{
			// initialize with last linesegment, since it is first.before
			for(Polygon2D.PolygonCorner pc : toValidate.getCorners())
			{
				double minAngleDeg = pc.orientation == Polygon2D.PolygonCornerOrientation.CONVEX ?
						minConvexCornerAngleDeg :
						minConcaveCornerAngleDeg;

				if(pc.angleDegAbs < minAngleDeg)
					return true;
			}

			return false;
		}

		private boolean isPolygonTooCloseToSelf()
		{
			int size = toValidate.getPoints().size();

			for(int li1 = 0; li1 < size; li1++)
				for(int li2 = 0; li2 < size; li2++)
				{
					if(li1 == li2)
						continue;

					// if this applies, we already went through the line combination before, with indexes switched
					if(li2 < li1)
						continue;

					double throughLinesDistance = getLineToLineDistanceAlongLines(toValidate, li1, li2);
					if(throughLinesDistance == 0) // lines are direct neighbors
						continue;

					double directDistance = toValidate.getLines().get(li1).getDistanceTo(toValidate.getLines().get(li2));

					// are lines far enough apart to check absolute distance
					if(throughLinesDistance/(directDistance+lineDistanceBufferDistance) < 2)
						continue;

					if(directDistance < minLineToLineDistance)
						return true;
				}

			return false;
		}

	}


	// UTIL
	private static double getLineToLineDistanceAlongLines(Polygon2D polygon, int li1, int li2)
	{
		int minIndex = Math.min(li1, li2);
		int maxIndex = Math.max(li1, li2);

		double betweenDistance = 0;
		double overEdgeDistance = 0;
		for(int i = 0; i < polygon.getLines().size(); i++)
		{
			double lineLength = polygon.getLines().get(i).getLength();

			if(i > minIndex && i < maxIndex)
				betweenDistance += lineLength;

			if(i < minIndex || i > maxIndex)
				overEdgeDistance += lineLength;
		}

		return Math.min(betweenDistance, overEdgeDistance);
	}

}
